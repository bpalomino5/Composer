Conflicts resolved:

1)  Removing E-Productions; 9 conflicts initially, 9 conflicts afterward
Initially CUP produced nine conflicts when generating the parser.  Several of these conflicts were Reduce/Reduce occurred with nonterminals that had a production rule producing and empty string.  After eliminating these productions there were still nine conflicts, however it was slightly easier to visualize where the conflicts were occurring so we did not change the grammar back.

2)  Nested if-statements; 9 conflicts initially, 9 conflicts afterward
We attempted to resolve a Shift/Reduce conflict that occurred when "_if ( Expr ) Stmt" was on the stack and "_else" was on the input.  We were able to introduce new terminal statements and modify the grammar rules to eliminate this conflict, but when we looked at CUP's default behavior, it was always shifting the "_else" to the stack rather than reducing the "_if ( Expr ) Stmt" into "IfStmt".  Since the behavior we want from the parser is to always shift the "_else" if is available, we allowed CUP's default behavior to handle this conflict, and we reversed our edits to the grammar.

3)  Precedence in the "Expr" nonterminal's productions; 9 conflicts initially, 2 conflicts afterward
When we originally constructed the grammar, we followed the procedure we learned in class for introducing additional nonterminals for each precedence group.  This produced Reduce/Reduce conflicts between the production rules containing a single nonterminal used to move to the next precedence group and the other production rules.  Eventually we attempted to resolve this by returning to the original rules without the additional nonterminals and relied on the precedence declarations earlier in the CUP file to determine precedence and associativity.  This eliminated all seven of the Reduce/Reduce conflicts caused by the extra nonterminals.

4)  VariableDecl followed by Stmt; 3 conflict initially, 2 conflicts afterward
CUP produced a Shift/Reduce conflict when "VariableDecl" was on the stack and "_id" was on the input.  This was caused by the production rules "H -> VariableDecl H | VariableDecl" and "StmtBlock -> { H I }".  When "VariableDecl" was on the stack and "_id" was on the input, it would not be clear whether the "_id" on the input was the beginning of another variable declaration or of a statement, so the parser wouldn't know whether to immediately reduce the "VariableDecl" to an "H" or whether to shift more tokens onto the stack.  Since "I" followed "H" in one of "StmtBlock"'s rules, and "I" could produce "Stmt", and "Stmt" could produce strings beginning with "_id", it would be unlear when just looking at the "_id" whether that "_id" would eventually reduce to a "VariableDecl" or to an "I".  This caused problems because there was no rule for reducing a "VariableDecl" unless it was either on top of the stack or immediately underneath the nonterminal "H" (which can only be produced by reducing from "VariableDecl" or "VariableDecl H").  To resolve this problem, we changed the rules for "StmtBlock" to be "StmtBlock -> { H } | { I } | {}" instead of "StmtBlock -> { H I } | { I } | { H } | { }" and added a rule "H -> VariableDecl I" to "H".  This removed the problem because with "VariableDecl I" able to reduce to "H", there were no problems with always shifting and "_id" to the stack when "VariableDecl" was on top, since doing this would no longer have the possibility of leaving a "VariableDecl" with no way to be reduced.

5)  Type[] and Lvalue[Expr]; 2 conflicts initially, 3 conflicts afterward
CUP produced a Reduce/Reduce conflict between the rules "Type -> Type []" and "Lvalue -> Lvalue [Expr]".  Since "Type" and "Lvalue" could both produce an "_id", if an "_id" was on the stack and a "[" was on the input, it would not be clear whether the "_id" on the stack should be reduced to a "Type" (in preparation for eventually reducing from "Type []" to "Type") or whether it should be reduced to "Lvalue" (in preparation for reducing from "Lvalue [Expr]" to "Lvalue").  We noticed that the nonterminal "Expr" could never be reduced to an empty string, so there would never be a case where "_id []" could reduce to Lvalue and completely match the rule for "Type".  We also noticed that the sequence of tokens "_id [" only occurred in these two rules.  This meant we could solve the problem by introducing a new nonterminal and production rule "IdLbracket -> _id [" and altering the rules for "Type" and "Lvalue" to use the new nonterminal "IdLbracket" (so they became "Type -> IdLbracket ]" and "Lvalue -> IdLbracket Expr ]".  Whenever the parser encountered a "[" on the input with an "_id" on the stack, it could shift the "[" to the stack, reduce it to "IdLbracket", and then make a decision from there based on whether the next token on the input was a "]" or not.  When we tried this solution in the cup file, it did not seem to process the input correctly.  We eventually realized that this was because we had previously defined precedence for "[" and "." in the precedence part of the cup file.  We removed the precedence declarations and this removed the problem but also revealed two new conflicts related to the "." token which had previously been hidden.

6)  Lvalue and Call and "_id ."; 3 conflicts initially, 3 conflicts afterward
CUP produced Shift/Reduce conflicts between the rules "Lvalue -> Lvalue . _id" and "Call -> _id . _id (Actuals) | _id . _id ()".  Since "Lvalue" could be reduced to "_id", in cases when "_id" was on the stack and "." was on the input, it would not be clear whether to reduce "_id" into "Lvalue" (in preparation for eventually reducing "Lvalue . _id" to "Lvalue") or whether to shift the "." onto the stack (in preparation for eventually reducing "_id . _id (Actuals)" or "_id . _id ()" to "Call").  We solved this by applying a method similar to the one we used to solve the problem with "Type[]" and "Lvalue[Expr]".  We first checked and confirmed that the sequence "_id ." only occurred in these two productions.  Then we introduced a new nonterminal and production rule "IdPeriod -> _id .".  We replaced the occurrences of "_id ." with "IdPeriod" in "Call"'s production rules ("Call -> IdPeriod _id (Actuals) | IdPeriod _id ()"), but instead of replacing "Lvalue . _id" with "IdPeriod _id" in "Lvalue"'s rule, we added a new rule to "Lvalue" ("Lvalue -> IdPeriod _id");  This was because we still needed the rule "Lvalue -> Lvalue . _id" in order to produce strings such as "_id . _id . _id . _id" or "_id [Expr] . _id".

7) Lvalue and IdPeriod; 3 conflicts initially, 3 conflicts afterward
The solution for the conflicts between "Lvalue" and "Call" did not actually reduce the number of conflicts generated by CUP, because there were new conflicts between "IdPeriod -> _id ." and "Lvalue -> _id".  However, CUP's default behavior (shifting) was the behavior we wanted in this case.  Previously, the "_id" needed to be reduced to "Lvalue" in order to later apply "Lvalue -> Lvalue . _id", but with the new rule "Lvalue -> IdPeriod _id", we could shift in all cases, reduce "_id ." to "IdPeriod" and still be able to reduce to "Lvalue" later.


After resolving conflicts:

CUP still generates three conflicts in the grammar, however its default behavior is able to handle these conflicts, so we did not use other methods to resolve them.  (These conflicts are described in steps 2 and 7).