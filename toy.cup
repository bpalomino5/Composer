/**
 * CUP file for generating the values for the Toy language tokens.
 * Check EOL characters if file does not seem to read.
 */

import java_cup.runtime.*;

/* Parser code */
parser code {:
    // StringBuilder for holding the output string.
    StringBuilder output = new StringBuilder();
    // Symbol table
    sym s = new sym();
    // ID of the current token
    int symIndex;

    /**
     * Return the string value for a given symbol.
     */
    public String getSymbolOutputString(Symbol symbol) {
        // Get int corresponding to Symbol type.
        symIndex = Integer.parseInt(symbol.toString().substring(1));
        // If symbol is an _id return its value.  Else, if symbol is an EOF return an empty string.
        // Else, return the value from sym.terminalNames[];
        String val;
        if (symIndex == 48) {
            val = (String) symbol.value + " ";
        } else if (symIndex == 0) {
            val = "";
        } else {
            val = sym.terminalNames[symIndex] + " ";
        }
        return val;
    }

    /**
     * Add a reduce rule with the given number to the output string.
     */
    public void reduceRuleOutput(int ruleNum) {
        output.insert(output.length() - 7, "[reduce ");
        output.insert(output.length() - 7, ruleNum);
        output.insert(output.length() - 7, ']');
    }
    
    /**
     * Override the default report_error() method.
     */
    public void report_fatal_error(String message, Object info) {
        System.out.println("[reject]");
    }
    
    /**
     * Override the default report_error() method.
     */
    public void report_error(String message, Object info) {
        // Do nothing
    }
    
    /**
     * Override the default report_syntax_error() method.
     */
    public void syntax_error(Symbol cur_token) {
        // Do nothing
    }
:}

/* Scan with */
scan with {:
    // Print and clear output string
    if (output.length() > 0) {
        System.out.println(output.toString());
        output.delete(0, output.length());
    }

    // Get next token and print it
    Symbol token = getScanner().next_token();
    System.out.print(getSymbolOutputString(token));

    // Add a "shift" to the end of the output string.
    output = output.append("[shift]");

    return token;
:}

/* terminals */
terminal _boolean;
terminal _break;
terminal _class;
terminal _double;
terminal _else;
terminal _extends;
terminal _for;
terminal _if;
terminal _implements;
terminal _int;
terminal _interface;
terminal _newarray;
terminal _println;
terminal _readln;
terminal _return;
terminal _string;
terminal _void;
terminal _while;
terminal _plus;
terminal _minus;
terminal _multiplication;
terminal _division;
terminal _mod;
terminal _less;
terminal _lessequal;
terminal _greater;
terminal _greaterequal;
terminal _equal;
terminal _notequal;
terminal _and;
terminal _or;
terminal _not;
terminal _assignop;
terminal _semicolon;
terminal _comma;
terminal _period;
terminal _leftparen;
terminal _rightparen;
terminal _leftbracket;
terminal _rightbracket;
terminal _leftbrace;
terminal _rightbrace;
terminal _intconstant;
terminal _doubleconstant;
terminal _stringconstant;
terminal _booleanconstant;
terminal _id;

/* non terminals */
non terminal Program;
non terminal A;
non terminal Decl;
non terminal VariableDecl;
non terminal FunctionDecl;
non terminal ClassDecl;
non terminal InterfaceDecl;
non terminal Variable;
non terminal Type;
non terminal Primitive;
non terminal Nonprimitive;
non terminal NonprimitiveArray;
non terminal Formals;
non terminal StmtBlock;
non terminal B;
non terminal C;
non terminal E;
non terminal F;
non terminal Field;
non terminal G;
non terminal Prototype;
non terminal H;
non terminal I;
non terminal Stmt;
non terminal IfStmt;
non terminal WhileStmt;
non terminal ForStmt;
non terminal BreakStmt;
non terminal ReturnStmt;
non terminal PrintStmt;
non terminal Expr;
non terminal L;
non terminal Lvalue;
non terminal Constant;
non terminal Call;
non terminal Actuals;
non terminal IdLbracket;
non terminal IdPeriod;

/* Precedence */
precedence left _assignop;
precedence left _or;
precedence left _and;
precedence left _equal, _notequal;
precedence nonassoc _greater, _greaterequal, _less, _lessequal;
precedence left _plus, _minus;
precedence left _multiplication, _division, _mod;
precedence left _not;


/* Grammar rules */
Program             ::= A
                        {:
                            reduceRuleOutput(1);
                            System.out.println(output.toString().substring(0, output.length() - 7));
                            output.delete(0, output.length());
                            if (symIndex == 0) {
                                System.out.println("[accept]");
                            }
                        :}
                    ;
A                   ::= Decl
                            {: reduceRuleOutput(2); :}
                    |   Decl A
                            {: reduceRuleOutput(3); :}
                    ;
Decl                ::= VariableDecl
                            {: reduceRuleOutput(4); :}
                    |   FunctionDecl
                            {: reduceRuleOutput(5); :}
                    |   ClassDecl
                            {: reduceRuleOutput(6); :}
                    |   InterfaceDecl
                            {: reduceRuleOutput(7); :}
                    ;
VariableDecl        ::= Variable _semicolon
                            {: reduceRuleOutput(8); :}
                    ;
Variable            ::= Type _id
                            {: reduceRuleOutput(9); :}
                    ;
Type                ::= Primitive
                            {: reduceRuleOutput(10); :}
                    |   Nonprimitive
                            {: reduceRuleOutput(11); :}
                    ;
Primitive           ::= _int
                            {: reduceRuleOutput(12); :}
                    |   _double
                            {: reduceRuleOutput(13); :}
                    |   _boolean
                            {: reduceRuleOutput(14); :}
                    |   _string
                            {: reduceRuleOutput(15); :}
                    |   Primitive _leftbracket _rightbracket
                            {: reduceRuleOutput(16); :}
                    ;
Nonprimitive        ::= NonprimitiveArray
                            {: reduceRuleOutput(17); :}
                    |   _id
                            {: reduceRuleOutput(18); :}
                    ;
NonprimitiveArray   ::= IdLbracket _rightbracket
                            {: reduceRuleOutput(19); :}
                    |   NonprimitiveArray _leftbracket _rightbracket
                            {: reduceRuleOutput(20); :}
                    ;
FunctionDecl        ::= Type _id _leftparen Formals _rightparen StmtBlock
                            {: reduceRuleOutput(21); :}
                    |   _void _id _leftparen Formals _rightparen StmtBlock
                            {: reduceRuleOutput(22); :}
                    |   Type _id _leftparen _rightparen StmtBlock
                            {: reduceRuleOutput(23); :}
                    |   _void _id _leftparen _rightparen StmtBlock
                            {: reduceRuleOutput(24); :}
                    ;
Formals             ::= B
                            {: reduceRuleOutput(25); :}
                    ;
B                   ::= Variable
                            {: reduceRuleOutput(26); :}
                    |   Variable _comma B
                            {: reduceRuleOutput(27); :}
                    ;
ClassDecl           ::= _class _id C F _leftbrace E _leftbrace
                            {: reduceRuleOutput(28); :}
                    |   _class _id F _leftbrace E _rightbrace
                            {: reduceRuleOutput(29); :}
                    |   _class _id C _leftbrace E _rightbrace
                            {: reduceRuleOutput(30); :}
                    |   _class _id _leftbrace E _rightbrace
                            {: reduceRuleOutput(31); :}
                    |   _class _id C F _leftbrace _rightbrace
                            {: reduceRuleOutput(32); :}
                    |   _class _id F _leftbrace _rightbrace
                            {: reduceRuleOutput(33); :}
                    |   _class _id C _leftbrace _rightbrace
                            {: reduceRuleOutput(34); :}
                    |   _class _id _leftbrace _rightbrace
                            {: reduceRuleOutput(35); :}
                    ;
C                   ::= _extends _id
                            {: reduceRuleOutput(36); :}
                    ;
F                   ::= _implements _id
                            {: reduceRuleOutput(37); :}
                    |   _implements _id _comma F
                            {: reduceRuleOutput(38); :}
                    ;
E                   ::= Field E
                            {: reduceRuleOutput(39); :}
                    |   Field
                            {: reduceRuleOutput(40); :}
                    ;
Field               ::= VariableDecl
                            {: reduceRuleOutput(41); :}
                    |   FunctionDecl
                            {: reduceRuleOutput(42); :}
                    ;
InterfaceDecl       ::= _interface _id _leftbrace G _rightbrace
                            {: reduceRuleOutput(43); :}
                    |   _interface _id _leftbrace _rightbrace
                            {: reduceRuleOutput(44); :}
                    ;
G                   ::= Prototype G
                            {: reduceRuleOutput(45); :}
                    |   Prototype
                            {: reduceRuleOutput(46); :}
                    ;
Prototype           ::= Type _id _leftparen Formals _rightparen _semicolon
                            {: reduceRuleOutput(47); :}
                    |   _void _id _leftparen Formals _rightparen _semicolon
                            {: reduceRuleOutput(48); :}
                    |   Type _id _leftparen _rightparen _semicolon
                            {: reduceRuleOutput(49); :}
                    |   _void _id _leftparen _rightparen _semicolon
                            {: reduceRuleOutput(50); :}
                    ;
StmtBlock           ::= _leftbrace I _rightbrace
                            {: reduceRuleOutput(51); :}
                    |   _leftbrace H _rightbrace
                            {: reduceRuleOutput(52); :}
                    |   _leftbrace _rightbrace
                            {: reduceRuleOutput(53); :}
                    ;
H                   ::= VariableDecl
                            {: reduceRuleOutput(54); :}
                    |   VariableDecl H
                            {: reduceRuleOutput(55); :}
                    |   VariableDecl I
                            {: reduceRuleOutput(56); :}
                    ;
I                   ::= Stmt I
                            {: reduceRuleOutput(57); :}
                    |   Stmt
                            {: reduceRuleOutput(58); :}
                    ;
Stmt                ::= Expr _semicolon
                            {: reduceRuleOutput(59); :}
                    |   IfStmt
                            {: reduceRuleOutput(60); :}
                    |   WhileStmt
                            {: reduceRuleOutput(61); :}
                    |   ForStmt
                            {: reduceRuleOutput(62); :}
                    |   BreakStmt
                            {: reduceRuleOutput(63); :}
                    |   ReturnStmt
                            {: reduceRuleOutput(64); :}
                    |   PrintStmt
                            {: reduceRuleOutput(65); :}
                    |   StmtBlock
                            {: reduceRuleOutput(66); :}
                    |   _semicolon
                            {: reduceRuleOutput(67); :}
                    ;
IfStmt              ::= _if _leftparen Expr _rightparen Stmt _else Stmt
                            {: reduceRuleOutput(68); :}
                    |   _if _leftparen Expr _rightparen Stmt
                            {: reduceRuleOutput(69); :}
                    ;
WhileStmt           ::= _while _leftparen Expr _rightparen Stmt
                            {: reduceRuleOutput(70); :}
                    ;
ForStmt             ::= _for _leftparen Expr _semicolon Expr _semicolon Expr _rightparen Stmt
                            {: reduceRuleOutput(71); :}
                    |   _for _leftparen _semicolon Expr _semicolon Expr _rightparen
                            {: reduceRuleOutput(72); :}
                    |   _for _leftparen Expr _semicolon Expr _semicolon _rightparen
                            {: reduceRuleOutput(73); :}
                    |   _for _leftparen _semicolon Expr _semicolon _rightparen
                            {: reduceRuleOutput(74); :}
                    ;
BreakStmt           ::= _break
                            {: reduceRuleOutput(75); :}
                    ;
ReturnStmt          ::= _return Expr _semicolon
                            {: reduceRuleOutput(76); :}
                    |   _return _semicolon
                            {: reduceRuleOutput(77); :}
                    ;
PrintStmt           ::= _println _leftparen L _rightparen _semicolon
                            {: reduceRuleOutput(78); :}
                    ;
L                   ::= Expr
                            {: reduceRuleOutput(79); :}
                    |   Expr _comma L
                            {: reduceRuleOutput(80); :}
                    ;
Expr                ::= Lvalue _assignop Expr
                            {: reduceRuleOutput(81); :}
                    |   Expr _or Expr
                            {: reduceRuleOutput(82); :}
                    |   Expr _and Expr
                            {: reduceRuleOutput(83); :}
                    |   Expr _equal Expr
                            {: reduceRuleOutput(84); :}
                    |   Expr _notequal Expr
                            {: reduceRuleOutput(85); :}
                    |   Expr _less Expr
                            {: reduceRuleOutput(86); :}
                    |   Expr _lessequal Expr
                            {: reduceRuleOutput(87); :}
                    |   Expr _greater Expr
                            {: reduceRuleOutput(88); :}
                    |   Expr _greaterequal Expr
                            {: reduceRuleOutput(89); :}
                    |   Expr _plus Expr
                            {: reduceRuleOutput(90); :}
                    |   Expr _minus Expr
                            {: reduceRuleOutput(91); :}
                    |   Expr _multiplication Expr
                            {: reduceRuleOutput(92); :}
                    |   Expr _division Expr
                            {: reduceRuleOutput(93); :}
                    |   Expr _mod Expr
                            {: reduceRuleOutput(94); :}
                    |   _not Expr
                            {: reduceRuleOutput(95); :}
                    |   _minus Expr
                            {: reduceRuleOutput(96); :} %prec _not 
                            // Used the precedence for _not because unary minus and _not are in the same precedence 
                            // group, and there is no nonterminal for unary minus.
                    |   _leftparen Expr _rightparen
                            {: reduceRuleOutput(97); :}
                    |   Constant
                            {: reduceRuleOutput(98); :}
                    |   Lvalue
                            {: reduceRuleOutput(99); :}
                    |   Call
                            {: reduceRuleOutput(100); :}
                    |   _readln _leftparen _rightparen
                            {: reduceRuleOutput(101); :}
                    |   _newarray _leftparen _intconstant _comma Type _rightparen
                            {: reduceRuleOutput(102); :}
                    ;
Lvalue              ::= _id
                            {: reduceRuleOutput(103); :}
                    |   IdLbracket Expr _rightbracket
                            {: reduceRuleOutput(104); :}
                    |   Lvalue _period _id
                            {: reduceRuleOutput(105); :}
                    |   IdPeriod _id
                            {: reduceRuleOutput(106); :}
                    ;
Call                ::= _id _leftparen Actuals _rightparen
                            {: reduceRuleOutput(107); :}
                    |   IdPeriod _id _leftparen Actuals _rightparen
                            {: reduceRuleOutput(108); :}
                    |   _id _leftparen _rightparen
                            {: reduceRuleOutput(109); :}
                    |   IdPeriod _id _leftparen _rightparen
                            {: reduceRuleOutput(110); :}
                    ;
Actuals             ::= L
                            {: reduceRuleOutput(111); :}
                    ;
Constant            ::= _intconstant
                            {: reduceRuleOutput(112); :}
                    |   _doubleconstant
                            {: reduceRuleOutput(113); :}
                    |   _stringconstant
                            {: reduceRuleOutput(114); :}
                    |   _booleanconstant
                            {: reduceRuleOutput(115); :}
                    ;
IdLbracket          ::= _id _leftbracket
                            {: reduceRuleOutput(116); :}
                    ;
IdPeriod            ::= _id _period
                            {: reduceRuleOutput(117); :}
                    ;